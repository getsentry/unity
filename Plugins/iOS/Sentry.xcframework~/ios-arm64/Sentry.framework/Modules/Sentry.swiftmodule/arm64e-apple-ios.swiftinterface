// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1.2 effective-5.10 (swiftlang-6.1.2.1.2 clang-1700.0.13.5)
// swift-module-flags: -target arm64e-apple-ios15.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Osize -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name Sentry
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -interface-compiler-version 6.1.2
import AVFoundation
import CommonCrypto
import CoreGraphics
import CoreMedia
import Darwin
import Foundation
import MachO
import MetricKit
import ObjectiveC.NSObjCRuntime
import Network
import ObjectiveC
import PDFKit
@_exported import Sentry
import Swift
import SwiftUI
import UIKit
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import ObjectiveC.runtime
extension Sentry.SentryLevel : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol SentryMetricsApiProtocol {
  func count(key: Swift.String, value: Swift.UInt, attributes: [Swift.String : any Sentry.SentryAttributeValue])
  func distribution(key: Swift.String, value: Swift.Double, unit: Sentry.SentryUnit?, attributes: [Swift.String : any Sentry.SentryAttributeValue])
  func gauge(key: Swift.String, value: Swift.Double, unit: Sentry.SentryUnit?, attributes: [Swift.String : any Sentry.SentryAttributeValue])
}
extension Sentry.SentryMetricsApiProtocol {
  public func count(key: Swift.String, value: Swift.UInt = 1, attributes: [Swift.String : any Sentry.SentryAttributeValue] = [:])
  public func distribution(key: Swift.String, value: Swift.Double, unit: Sentry.SentryUnit? = nil, attributes: [Swift.String : any Sentry.SentryAttributeValue] = [:])
  public func gauge(key: Swift.String, value: Swift.Double, unit: Sentry.SentryUnit? = nil, attributes: [Swift.String : any Sentry.SentryAttributeValue] = [:])
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class SentryExperimentalOptions : ObjectiveC.NSObject {
  @objc final public var enableUnhandledCPPExceptionsV2: Swift.Bool
  @objc final public var enableSessionReplayInUnreliableEnvironment: Swift.Bool
  @objc final public var enableMetrics: Swift.Bool
  final public var beforeSendMetric: ((Sentry.SentryMetric) -> Sentry.SentryMetric?)?
  @objc override dynamic public init()
  @objc deinit
}
@objc @objcMembers final public class SentryFeedback : ObjectiveC.NSObject {
  @objc public enum SentryFeedbackSource : Swift.Int {
    public var serialize: Swift.String {
      get
    }
    case widget
    case custom
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public init(message: Swift.String, name: Swift.String?, email: Swift.String?, source: Sentry.SentryFeedback.SentryFeedbackSource = .widget, associatedEventId: Sentry.SentryId? = nil, attachments: [Sentry.Attachment]? = nil)
  @objc deinit
}
extension Sentry.SentryFeedback : Sentry.SentrySerializable {
}
extension Sentry.SentryFeedback {
  @objc final public func serialize() -> [Swift.String : Any]
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class SentryUserFeedbackFormConfiguration : ObjectiveC.NSObject {
  @objc final public var useSentryUser: Swift.Bool
  @objc final public var showBranding: Swift.Bool
  @objc final public var formTitle: Swift.String
  @objc final public var messageLabel: Swift.String
  @objc final public var messagePlaceholder: Swift.String
  @objc final public var messageTextViewAccessibilityLabel: Swift.String {
    @objc get
    @objc set
  }
  @objc final public var isRequiredLabel: Swift.String
  @objc final public var removeScreenshotButtonLabel: Swift.String
  @objc final public var removeScreenshotButtonAccessibilityLabel: Swift.String {
    @objc get
    @objc set
  }
  @objc final public var isNameRequired: Swift.Bool
  @objc final public var showName: Swift.Bool
  @objc final public var nameLabel: Swift.String
  @objc final public var namePlaceholder: Swift.String
  @objc final public var nameTextFieldAccessibilityLabel: Swift.String {
    @objc get
    @objc set
  }
  @objc final public var isEmailRequired: Swift.Bool
  @objc final public var showEmail: Swift.Bool
  @objc final public var emailLabel: Swift.String
  @objc final public var emailPlaceholder: Swift.String
  @objc final public var emailTextFieldAccessibilityLabel: Swift.String {
    @objc get
    @objc set
  }
  @objc final public var submitButtonLabel: Swift.String
  @objc final public var submitButtonAccessibilityLabel: Swift.String {
    @objc get
    @objc set
  }
  @objc final public var cancelButtonLabel: Swift.String
  @objc final public var cancelButtonAccessibilityLabel: Swift.String {
    @objc get
    @objc set
  }
  @objc final public var unexpectedErrorText: Swift.String
  @objc final public var validationErrorMessage: (_ multipleErrors: Swift.Bool) -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class SentryProfileOptions : ObjectiveC.NSObject {
  @objc public enum SentryProfileLifecycle : Swift.Int {
    case manual
    case trace
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc final public var lifecycle: Sentry.SentryProfileOptions.SentryProfileLifecycle
  @objc final public var sessionSampleRate: Swift.Float
  @objc final public var profileAppStarts: Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc final public class SentryLogger : ObjectiveC.NSObject {
  final public func trace(_ message: Sentry.SentryLogMessage, attributes: [Swift.String : Any] = [:])
  @objc(trace:) final public func trace(_ body: Swift.String)
  @objc(trace:attributes:) final public func trace(_ body: Swift.String, attributes: [Swift.String : Any])
  final public func debug(_ message: Sentry.SentryLogMessage, attributes: [Swift.String : Any] = [:])
  @objc(debug:) final public func debug(_ body: Swift.String)
  @objc(debug:attributes:) final public func debug(_ body: Swift.String, attributes: [Swift.String : Any])
  final public func info(_ message: Sentry.SentryLogMessage, attributes: [Swift.String : Any] = [:])
  @objc(info:) final public func info(_ body: Swift.String)
  @objc(info:attributes:) final public func info(_ body: Swift.String, attributes: [Swift.String : Any])
  final public func warn(_ message: Sentry.SentryLogMessage, attributes: [Swift.String : Any] = [:])
  @objc(warn:) final public func warn(_ body: Swift.String)
  @objc(warn:attributes:) final public func warn(_ body: Swift.String, attributes: [Swift.String : Any])
  final public func error(_ message: Sentry.SentryLogMessage, attributes: [Swift.String : Any] = [:])
  @objc(error:) final public func error(_ body: Swift.String)
  @objc(error:attributes:) final public func error(_ body: Swift.String, attributes: [Swift.String : Any])
  final public func fatal(_ message: Sentry.SentryLogMessage, attributes: [Swift.String : Any] = [:])
  @objc(fatal:) final public func fatal(_ body: Swift.String)
  @objc(fatal:attributes:) final public func fatal(_ body: Swift.String, attributes: [Swift.String : Any])
  @objc deinit
}
@available(*, deprecated, message: "Use SentrySpanOperationUiLoad and other constants from the Sentry module instead")
public enum SentrySpanOperation {
  public static let uiLoad: Swift.String
}
extension Swift.FixedWidthInteger {
  @discardableResult
  @inlinable postfix internal static func ++ (lhs: inout Self) -> Self {
        defer { lhs += 1 }
        return lhs
    }
}
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func sentryReplayPreviewMask(redactOptions: (any Sentry.SentryRedactOptions)? = nil, opacity: Swift.Float = 1) -> some SwiftUICore.View
  
}
public struct SentryLogMessage : Swift.ExpressibleByStringInterpolation {
  public init(stringLiteral value: Swift.String)
  public init(stringInterpolation: Sentry.SentryLogMessage.StringInterpolation)
  public struct StringInterpolation : Swift.StringInterpolationProtocol {
    public init(literalCapacity: Swift.Int, interpolationCount: Swift.Int)
    public mutating func appendLiteral(_ literal: Swift.String)
    public mutating func appendInterpolation(_ value: @autoclosure @escaping () -> Swift.String)
    public mutating func appendInterpolation(_ value: @autoclosure @escaping () -> Swift.Bool)
    public mutating func appendInterpolation(_ value: @autoclosure @escaping () -> Swift.Int)
    public mutating func appendInterpolation(_ value: @autoclosure @escaping () -> Swift.Double)
    public mutating func appendInterpolation(_ value: @autoclosure @escaping () -> Swift.Float)
    public mutating func appendInterpolation<T>(_ value: @autoclosure @escaping () -> T) where T : Swift.CustomStringConvertible
    public typealias StringLiteralType = Swift.String
  }
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public enum SentryRedactRegionType : Swift.String, Swift.Codable, Swift.Equatable {
  case redact
  case clipOut
  case clipBegin
  case clipEnd
  case redactSwiftUI
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc public protocol SentryUIViewControllerDescriptor : ObjectiveC.NSObjectProtocol {
  @objc var sentryName: Swift.String { get }
}
extension Foundation.Data {
  public init(contentsOfWithSentryTracing url: Foundation.URL, options: Foundation.Data.ReadingOptions = []) throws
  public func writeWithSentryTracing(to url: Foundation.URL, options: Foundation.Data.WritingOptions = []) throws
}
@objc final public class SentryHub : ObjectiveC.NSObject {
  @objc(initWithClient:andScope:) public init(client: Sentry.SentryClient?, andScope scope: Sentry.Scope?)
  @objc final public func startSession()
  @objc final public func endSession()
  @objc final public func endSession(withTimestamp timestamp: Foundation.Date)
  @discardableResult
  @objc(captureEvent:) final public func capture(event: Sentry.Event) -> Sentry.SentryId
  @discardableResult
  @objc(captureEvent:withScope:) final public func capture(event: Sentry.Event, scope: Sentry.Scope) -> Sentry.SentryId
  @discardableResult
  @objc final public func startTransaction(name: Swift.String, operation: Swift.String) -> any Sentry.Span
  @discardableResult
  @objc final public func startTransaction(name: Swift.String, operation: Swift.String, bindToScope: Swift.Bool) -> any Sentry.Span
  @discardableResult
  @objc(startTransactionWithContext:) final public func startTransaction(transactionContext: Sentry.TransactionContext) -> any Sentry.Span
  @discardableResult
  @objc(startTransactionWithContext:bindToScope:) final public func startTransaction(transactionContext: Sentry.TransactionContext, bindToScope: Swift.Bool) -> any Sentry.Span
  @discardableResult
  @objc(startTransactionWithContext:bindToScope:customSamplingContext:) final public func startTransaction(transactionContext: Sentry.TransactionContext, bindToScope: Swift.Bool, customSamplingContext: [Swift.String : Any]) -> any Sentry.Span
  @discardableResult
  @objc(startTransactionWithContext:customSamplingContext:) final public func startTransaction(transactionContext: Sentry.TransactionContext, customSamplingContext: [Swift.String : Any]) -> any Sentry.Span
  @discardableResult
  @objc(captureError:) final public func capture(error: Foundation.NSError) -> Sentry.SentryId
  @discardableResult
  @objc(captureError:withScope:) final public func capture(error: any Swift.Error, scope: Sentry.Scope) -> Sentry.SentryId
  @discardableResult
  @objc(captureException:) final public func capture(exception: Foundation.NSException) -> Sentry.SentryId
  @discardableResult
  @objc(captureException:withScope:) final public func capture(exception: Foundation.NSException, scope: Sentry.Scope) -> Sentry.SentryId
  @discardableResult
  @objc(captureMessage:) final public func capture(message: Swift.String) -> Sentry.SentryId
  @discardableResult
  @objc(captureMessage:withScope:) final public func capture(message: Swift.String, scope: Sentry.Scope) -> Sentry.SentryId
  @objc(captureFeedback:) final public func capture(feedback: Sentry.SentryFeedback)
  @objc final public func configureScope(_ callback: @escaping (Sentry.Scope) -> Swift.Void)
  @objc(addBreadcrumb:) final public func add(_ crumb: Sentry.Breadcrumb)
  @objc final public func getClient() -> Sentry.SentryClient?
  @objc final public var scope: Sentry.Scope {
    @objc get
  }
  @objc final public var logger: Sentry.SentryLogger {
    @objc get
  }
  @objc final public func bindClient(_ client: Sentry.SentryClient?)
  @objc final public func hasIntegration(_ integrationName: Swift.String) -> Swift.Bool
  @objc final public func isIntegrationInstalled(_ integrationClass: Swift.AnyClass) -> Swift.Bool
  @objc final public func setUser(_ user: Sentry.User?)
  @objc final public func reportFullyDisplayed()
  @objc(flush:) final public func flush(timeout: Foundation.TimeInterval)
  @objc final public func close()
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(SentryDsn) final public class SentryDsn : ObjectiveC.NSObject {
  @objc final public let url: Foundation.URL
  @objc public init?(string dsnString: Swift.String?, didFailWithError error: Foundation.NSErrorPointer)
  convenience public init(string: Swift.String?) throws
  @objc final public func getEnvelopeEndpoint() -> Foundation.URL
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(SentryOptions) final public class Options : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc final public var dsn: Swift.String? {
    @objc get
    @objc set
  }
  @objc final public var parsedDsn: Sentry.SentryDsn?
  @objc final public var debug: Swift.Bool
  @objc final public var diagnosticLevel: Sentry.SentryLevel
  @objc final public var releaseName: Swift.String?
  @objc final public var dist: Swift.String?
  @objc final public var environment: Swift.String
  @objc final public var enabled: Swift.Bool
  @objc final public var shutdownTimeInterval: Swift.Double
  @objc final public var enableCrashHandler: Swift.Bool
  @objc final public var enableSigtermReporting: Swift.Bool
  @objc final public var maxBreadcrumbs: Swift.UInt
  @objc final public var enableNetworkBreadcrumbs: Swift.Bool
  @objc final public var maxCacheItems: Swift.UInt
  @objc final public var beforeSend: Sentry.SentryBeforeSendEventCallback?
  @objc final public var beforeSendSpan: Sentry.SentryBeforeSendSpanCallback?
  @objc final public var enableLogs: Swift.Bool
  @objc final public var beforeSendLog: ((Sentry.SentryLog) -> Sentry.SentryLog?)?
  @objc final public var beforeBreadcrumb: Sentry.SentryBeforeBreadcrumbCallback?
  @objc final public var beforeCaptureScreenshot: Sentry.SentryBeforeCaptureScreenshotCallback?
  @objc final public var beforeCaptureViewHierarchy: Sentry.SentryBeforeCaptureScreenshotCallback?
  @objc final public var onCrashedLastRun: Sentry.SentryOnCrashedLastRunCallback?
  @objc final public var sampleRate: Foundation.NSNumber? {
    @objc get
    @objc set
  }
  @objc final public var enableAutoSessionTracking: Swift.Bool
  @objc final public var enableGraphQLOperationTracking: Swift.Bool
  @objc final public var enableWatchdogTerminationTracking: Swift.Bool
  @objc final public var sessionTrackingIntervalMillis: Swift.UInt
  @objc final public var attachStacktrace: Swift.Bool
  @objc final public var maxAttachmentSize: Swift.UInt
  @objc final public var sendDefaultPii: Swift.Bool
  @objc final public var enableAutoPerformanceTracing: Swift.Bool
  @objc final public var enablePersistingTracesWhenCrashing: Swift.Bool
  @objc final public var initialScope: (Sentry.Scope) -> Sentry.Scope
  @objc final public var enableUIViewControllerTracing: Swift.Bool
  @objc final public var attachScreenshot: Swift.Bool
  @objc final public var screenshot: Sentry.SentryViewScreenshotOptions
  @objc final public var attachViewHierarchy: Swift.Bool
  @objc final public var reportAccessibilityIdentifier: Swift.Bool
  @objc final public var enableUserInteractionTracing: Swift.Bool
  @objc final public var idleTimeout: Swift.Double
  @objc final public var enablePreWarmedAppStartTracing: Swift.Bool
  @objc final public var enableReportNonFullyBlockingAppHangs: Swift.Bool
  @objc final public var sessionReplay: Sentry.SentryReplayOptions
  @objc final public var enableNetworkTracking: Swift.Bool
  @objc final public var enableFileIOTracing: Swift.Bool
  @objc final public var enableDataSwizzling: Swift.Bool
  @objc final public var enableFileManagerSwizzling: Swift.Bool
  @objc final public var tracesSampleRate: Foundation.NSNumber? {
    @objc get
    @objc set
  }
  @objc final public var tracesSampler: Sentry.SentryTracesSamplerCallback?
  @objc final public var isTracingEnabled: Swift.Bool {
    @objc get
  }
  @objc final public var inAppIncludes: [Swift.String] {
    get
  }
  @objc final public func add(inAppInclude: Swift.String)
  @objc weak final public var urlSessionDelegate: (any Foundation.URLSessionDelegate)?
  @objc final public var urlSession: Foundation.URLSession?
  @objc final public var enableSwizzling: Swift.Bool
  @objc final public var swizzleClassNameExcludes: Swift.Set<Swift.String>
  @objc final public var enableCoreDataTracing: Swift.Bool
  @objc final public var configureProfiling: ((Sentry.SentryProfileOptions) -> Swift.Void)? {
    @objc get
    @objc set
  }
  @objc final public var sendClientReports: Swift.Bool
  @objc final public var enableAppHangTracking: Swift.Bool
  @objc final public var appHangTimeoutInterval: Swift.Double
  @objc final public var enableAutoBreadcrumbTracking: Swift.Bool
  @objc final public var enablePropagateTraceparent: Swift.Bool
  @objc final public var tracePropagationTargets: [Any] {
    @objc get
    @objc set
  }
  @objc final public var enableCaptureFailedRequests: Swift.Bool
  @objc final public var failedRequestStatusCodes: [Sentry.HttpStatusCodeRange]
  @objc final public var failedRequestTargets: [Any] {
    @objc get
    @objc set
  }
  @objc final public var enableMetricKit: Swift.Bool
  @objc final public var enableMetricKitRawPayload: Swift.Bool
  @objc final public var enableTimeToFullDisplayTracing: Swift.Bool
  @objc final public var swiftAsyncStacktraces: Swift.Bool
  @objc final public var cacheDirectoryPath: Swift.String
  @objc final public var enableSpotlight: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public var spotlightUrl: Swift.String
  @objc final public var experimental: Sentry.SentryExperimentalOptions
  @available(iOSApplicationExtension, unavailable)
  @objc final public var configureUserFeedback: ((Sentry.SentryUserFeedbackConfiguration) -> Swift.Void)? {
    @objc get
    @objc set
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class SentryFeedbackAPI : ObjectiveC.NSObject {
  @available(iOSApplicationExtension, unavailable)
  @objc final public func showWidget()
  @available(iOSApplicationExtension, unavailable)
  @objc final public func hideWidget()
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class SentryUserFeedbackThemeConfiguration : ObjectiveC.NSObject {
  @objc final public var fontFamily: Swift.String? {
    @objc get
    @objc set
  }
  @objc final public var foreground: UIKit.UIColor
  @objc final public var background: UIKit.UIColor
  @objc final public var submitForeground: UIKit.UIColor
  @objc final public var submitBackground: UIKit.UIColor
  @objc final public var buttonForeground: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc final public var buttonBackground: UIKit.UIColor
  @objc final public var errorColor: UIKit.UIColor
  @objc final public class SentryFormElementOutlineStyle : ObjectiveC.NSObject {
    final public var color: UIKit.UIColor
    final public var cornerRadius: CoreFoundation.CGFloat
    final public var outlineWidth: CoreFoundation.CGFloat
    @objc public init(color: UIKit.UIColor = UIColor(white: 204 / 255, alpha: 1), cornerRadius: CoreFoundation.CGFloat = 5, outlineWidth: CoreFoundation.CGFloat = 0.5)
    @objc deinit
  }
  @objc final public var outlineStyle: Sentry.SentryUserFeedbackThemeConfiguration.SentryFormElementOutlineStyle {
    @objc get
    @objc set
  }
  @objc final public var inputBackground: UIKit.UIColor
  @objc final public var inputForeground: UIKit.UIColor
  @objc override dynamic public init()
  @objc deinit
}
@available(macOS 10.15, *)
@_Concurrency.MainActor @preconcurrency public struct SentryTracedView<Content> : SwiftUICore.View where Content : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(_ viewName: Swift.String? = nil, waitForFullDisplay: Swift.Bool? = nil, @SwiftUICore.ViewBuilder content: @escaping () -> Content)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @available(macOS 10.15, *)
  public typealias Body = @_opaqueReturnTypeOf("$s6Sentry0A10TracedViewV4bodyQrvp", 0) __<Content>
}
@available(macOS 10.15, *)
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func sentryTrace(_ viewName: Swift.String? = nil, waitForFullDisplay: Swift.Bool? = nil) -> some SwiftUICore.View
  
}
public enum SentryUnit : Swift.Equatable {
  case nanosecond
  case microsecond
  case millisecond
  case second
  case minute
  case hour
  case day
  case week
  case bit
  case byte
  case kilobyte
  case kibibyte
  case megabyte
  case mebibyte
  case gigabyte
  case gibibyte
  case terabyte
  case tebibyte
  case petabyte
  case pebibyte
  case exabyte
  case exbibyte
  case ratio
  case percent
  case generic(Swift.String)
}
extension Sentry.SentryUnit : Swift.RawRepresentable {
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
extension Sentry.SentryUnit : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Sentry.SentryUnit : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
public struct SentryMetric {
  public typealias Value = Sentry.SentryMetricValue
  public typealias Attribute = Sentry.SentryAttributeContent
  public typealias Unit = Sentry.SentryUnit
  public var timestamp: Foundation.Date
  public var name: Swift.String
  public var traceId: Sentry.SentryId
  public var value: Sentry.SentryMetric.Value
  public var unit: Sentry.SentryUnit?
  public var attributes: [Swift.String : Sentry.SentryMetric.Attribute]
}
extension Sentry.SentryMetric : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@objc @_hasMissingDesignatedInitializers @objcMembers final public class SentryLog : ObjectiveC.NSObject {
  public typealias Attribute = Sentry.SentryAttribute
  @objc final public var timestamp: Foundation.Date
  @objc final public var traceId: Sentry.SentryId
  @objc final public var level: Sentry.SentryLog.Level
  @objc final public var body: Swift.String
  @objc final public var attributes: [Swift.String : Sentry.SentryLog.Attribute]
  @objc final public var severityNumber: Foundation.NSNumber?
  @objc convenience public init(level: Sentry.SentryLog.Level, body: Swift.String)
  @objc convenience public init(level: Sentry.SentryLog.Level, body: Swift.String, attributes: [Swift.String : Sentry.SentryLog.Attribute])
  @objc final public func setAttribute(_ attribute: Sentry.SentryLog.Attribute?, forKey key: Swift.String)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objcMembers final public class SentryRedactViewHelper : ObjectiveC.NSObject {
  @objc public static func clipOutView(_ view: UIKit.UIView)
  @objc public static func maskSwiftUI(_ view: UIKit.UIView)
  @objc deinit
}
public enum SentryAttributeContent : Swift.Equatable, Swift.Hashable {
  case string(Swift.String)
  case boolean(Swift.Bool)
  case integer(Swift.Int)
  case double(Swift.Double)
  case stringArray([Swift.String])
  case booleanArray([Swift.Bool])
  case integerArray([Swift.Int])
  case doubleArray([Swift.Double])
  public static func == (a: Sentry.SentryAttributeContent, b: Sentry.SentryAttributeContent) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Sentry.SentryAttributeContent : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Sentry.SentryAttributeContent : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension Sentry.SentryAttributeContent : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension Sentry.SentryAttributeContent : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.FloatLiteralType)
  public typealias FloatLiteralType = Swift.FloatLiteralType
}
extension Sentry.SentryAttributeContent : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.IntegerLiteralType)
  public typealias IntegerLiteralType = Swift.IntegerLiteralType
}
@objc @_hasMissingDesignatedInitializers @objcMembers final public class SentryAttribute : ObjectiveC.NSObject {
  @objc final public let type: Swift.String
  @objc final public let value: Any
  @objc public init(string value: Swift.String)
  @objc public init(boolean value: Swift.Bool)
  @objc public init(integer value: Swift.Int)
  @objc public init(double value: Swift.Double)
  @objc public init(float value: Swift.Float)
  @objc public init(stringArray values: [Swift.String])
  @objc public init(booleanArray values: [Swift.Bool])
  @objc public init(integerArray values: [Swift.Int])
  @objc public init(doubleArray values: [Swift.Double])
  @objc public init(floatArray values: [Swift.Float])
  @objc deinit
}
extension Foundation.FileManager {
  public func createFileWithSentryTracing(atPath path: Swift.String, contents data: Foundation.Data?, attributes attr: [Foundation.FileAttributeKey : Any]? = nil) -> Swift.Bool
  public func removeItemWithSentryTracing(at url: Foundation.URL) throws
  public func removeItemWithSentryTracing(atPath path: Swift.String) throws
  public func copyItemWithSentryTracing(at srcURL: Foundation.URL, to dstURL: Foundation.URL) throws
  public func copyItemWithSentryTracing(atPath srcPath: Swift.String, toPath dstPath: Swift.String) throws
  public func moveItemWithSentryTracing(at srcURL: Foundation.URL, to dstURL: Foundation.URL) throws
  public func moveItemWithSentryTracing(atPath srcPath: Swift.String, toPath dstPath: Swift.String) throws
}
@objc public enum SentryTransactionNameSource : Swift.Int {
  @objc(kSentryTransactionNameSourceCustom) case custom = 0
  @objc(kSentryTransactionNameSourceUrl) case url
  @objc(kSentryTransactionNameSourceRoute) case route
  @objc(kSentryTransactionNameSourceView) case view
  @objc(kSentryTransactionNameSourceComponent) case component
  @objc(kSentryTransactionNameSourceTask) case sourceTask
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @objc final public class SentryClient : ObjectiveC.NSObject {
  @objc public init?(options: Sentry.Options)
  @objc final public var isEnabled: Swift.Bool {
    @objc get
  }
  @objc final public var options: Sentry.Options {
    @objc get
    @objc set
  }
  @discardableResult
  @objc(captureEvent:) final public func capture(event: Sentry.Event) -> Sentry.SentryId
  @discardableResult
  @objc(captureEvent:withScope:) final public func capture(event: Sentry.Event, scope: Sentry.Scope) -> Sentry.SentryId
  @discardableResult
  @objc(captureError:) final public func capture(error: any Swift.Error) -> Sentry.SentryId
  @discardableResult
  @objc(captureError:withScope:) final public func capture(error: any Swift.Error, scope: Sentry.Scope) -> Sentry.SentryId
  @discardableResult
  @objc(captureException:) final public func capture(exception: Foundation.NSException) -> Sentry.SentryId
  @discardableResult
  @objc(captureException:withScope:) final public func capture(exception: Foundation.NSException, scope: Sentry.Scope) -> Sentry.SentryId
  @discardableResult
  @objc(captureMessage:) final public func capture(message: Swift.String) -> Sentry.SentryId
  @discardableResult
  @objc(captureMessage:withScope:) final public func capture(message: Swift.String, scope: Sentry.Scope) -> Sentry.SentryId
  @objc(captureFeedback:withScope:) final public func capture(feedback: Sentry.SentryFeedback, scope: Sentry.Scope)
  @objc(captureLog:withScope:) final public func capture(log: Sentry.SentryLog, scope: Sentry.Scope)
  @objc(flush:) final public func flush(timeout: Foundation.TimeInterval)
  @objc final public func close()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class SentryUserFeedbackWidgetConfiguration : ObjectiveC.NSObject {
  @objc final public var autoInject: Swift.Bool
  @objc final public var labelText: Swift.String? {
    @objc get
    @objc set
  }
  @objc final public var showIcon: Swift.Bool
  @objc final public var widgetAccessibilityLabel: Swift.String? {
    @objc get
    @objc set
  }
  @objc final public var windowLevel: UIKit.UIWindow.Level
  @objc final public var location: UIKit.NSDirectionalRectEdge
  @objc final public var layoutUIOffset: UIKit.UIOffset
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class SentryUserFeedbackConfiguration : ObjectiveC.NSObject {
  @objc final public var animations: Swift.Bool
  @objc final public var configureWidget: ((Sentry.SentryUserFeedbackWidgetConfiguration) -> Swift.Void)?
  @objc final public var useShakeGesture: Swift.Bool
  @objc final public var showFormForScreenshots: Swift.Bool
  @objc final public var customButton: UIKit.UIButton?
  @objc final public var configureForm: ((Sentry.SentryUserFeedbackFormConfiguration) -> Swift.Void)?
  @objc final public var tags: [Swift.String : Any]?
  @objc final public var onFormOpen: (() -> Swift.Void)?
  @objc final public var onFormClose: (() -> Swift.Void)?
  @objc final public var onSubmitSuccess: (([Swift.String : Any]) -> Swift.Void)?
  @objc final public var onSubmitError: ((any Swift.Error) -> Swift.Void)?
  @objc final public var configureTheme: ((Sentry.SentryUserFeedbackThemeConfiguration) -> Swift.Void)?
  @objc final public var configureDarkTheme: ((Sentry.SentryUserFeedbackThemeConfiguration) -> Swift.Void)? {
    @objc get
    @objc @available(*, deprecated, message: "Use dynamic UIColor instead of the dark theme.")
    set
  }
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc final public class SentrySDK : ObjectiveC.NSObject {
  @objc public static var span: (any Sentry.Span)? {
    @objc get
  }
  @objc public static var isEnabled: Swift.Bool {
    @objc get
  }
  @objc public static var replay: Sentry.SentryReplayApi {
    @objc get
  }
  @objc public static var logger: Sentry.SentryLogger {
    @objc get
  }
  public static var metrics: any Sentry.SentryMetricsApiProtocol
  @objc public static func start(options: Sentry.Options)
  @objc public static func start(configureOptions: @escaping (Sentry.Options) -> Swift.Void)
  @discardableResult
  @objc(captureEvent:) public static func capture(event: Sentry.Event) -> Sentry.SentryId
  @discardableResult
  @objc(captureEvent:withScope:) public static func capture(event: Sentry.Event, scope: Sentry.Scope) -> Sentry.SentryId
  @discardableResult
  @objc(captureEvent:withScopeBlock:) public static func capture(event: Sentry.Event, block: @escaping (Sentry.Scope) -> Swift.Void) -> Sentry.SentryId
  @discardableResult
  @objc public static func startTransaction(name: Swift.String, operation: Swift.String) -> any Sentry.Span
  @discardableResult
  @objc public static func startTransaction(name: Swift.String, operation: Swift.String, bindToScope: Swift.Bool) -> any Sentry.Span
  @discardableResult
  @objc(startTransactionWithContext:) public static func startTransaction(transactionContext: Sentry.TransactionContext) -> any Sentry.Span
  @discardableResult
  @objc(startTransactionWithContext:bindToScope:) public static func startTransaction(transactionContext: Sentry.TransactionContext, bindToScope: Swift.Bool) -> any Sentry.Span
  @discardableResult
  @objc(startTransactionWithContext:bindToScope:customSamplingContext:) public static func startTransaction(transactionContext: Sentry.TransactionContext, bindToScope: Swift.Bool, customSamplingContext: [Swift.String : Any]) -> any Sentry.Span
  @discardableResult
  @objc(startTransactionWithContext:customSamplingContext:) public static func startTransaction(transactionContext: Sentry.TransactionContext, customSamplingContext: [Swift.String : Any]) -> any Sentry.Span
  @discardableResult
  @objc(captureError:) public static func capture(error: any Swift.Error) -> Sentry.SentryId
  @discardableResult
  @objc(captureError:withScope:) public static func capture(error: any Swift.Error, scope: Sentry.Scope) -> Sentry.SentryId
  @discardableResult
  @objc(captureError:withScopeBlock:) public static func capture(error: any Swift.Error, block: @escaping (Sentry.Scope) -> Swift.Void) -> Sentry.SentryId
  @discardableResult
  @objc(captureException:) public static func capture(exception: Foundation.NSException) -> Sentry.SentryId
  @discardableResult
  @objc(captureException:withScope:) public static func capture(exception: Foundation.NSException, scope: Sentry.Scope) -> Sentry.SentryId
  @discardableResult
  @objc(captureException:withScopeBlock:) public static func capture(exception: Foundation.NSException, block: @escaping (Sentry.Scope) -> Swift.Void) -> Sentry.SentryId
  @discardableResult
  @objc(captureMessage:) public static func capture(message: Swift.String) -> Sentry.SentryId
  @discardableResult
  @objc(captureMessage:withScope:) public static func capture(message: Swift.String, scope: Sentry.Scope) -> Sentry.SentryId
  @discardableResult
  @objc(captureMessage:withScopeBlock:) public static func capture(message: Swift.String, block: @escaping (Sentry.Scope) -> Swift.Void) -> Sentry.SentryId
  @objc(captureFeedback:) public static func capture(feedback: Sentry.SentryFeedback)
  @objc public static let feedback: Sentry.SentryFeedbackAPI
  @objc(addBreadcrumb:) public static func addBreadcrumb(_ crumb: Sentry.Breadcrumb)
  @objc(configureScope:) public static func configureScope(_ callback: @escaping (Sentry.Scope) -> Swift.Void)
  @objc public static var crashedLastRun: Swift.Bool {
    @objc get
  }
  @objc public static var detectedStartUpCrash: Swift.Bool {
    @objc get
  }
  @objc public static func setUser(_ user: Sentry.User?)
  @objc public static func startSession()
  @objc public static func endSession()
  @objc public static func crash()
  @objc public static func reportFullyDisplayed()
  @objc public static func pauseAppHangTracking()
  @objc public static func resumeAppHangTracking()
  @objc(flush:) public static func flush(timeout: Foundation.TimeInterval)
  @objc public static func close()
  @objc public static func startProfiler()
  @objc public static func stopProfiler()
  @objc override dynamic public init()
  @objc deinit
}
@available(*, deprecated, message: "Use SentryTraceOriginAutoUISwiftUI and other constants from the Sentry module instead")
public enum SentryTraceOrigin {
  public static let autoUISwiftUI: Swift.String
  public static let autoUITimeToDisplay: Swift.String
}
extension UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency public func sentryReplayMask()
  @_Concurrency.MainActor @preconcurrency public func sentryReplayUnmask()
}
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func sentryReplayMask() -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func sentryReplayUnmask() -> some SwiftUICore.View
  
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objcMembers public class SentryReplayOptions : ObjectiveC.NSObject, Sentry.SentryRedactOptions {
  @_hasMissingDesignatedInitializers public class DefaultValues {
    public static let sessionSampleRate: Swift.Float
    public static let onErrorSampleRate: Swift.Float
    public static let maskAllText: Swift.Bool
    public static let maskAllImages: Swift.Bool
    public static let enableViewRendererV2: Swift.Bool
    public static let enableFastViewRendering: Swift.Bool
    public static let quality: Sentry.SentryReplayOptions.SentryReplayQuality
    public static let maskedViewClasses: [Swift.AnyClass]
    public static let unmaskedViewClasses: [Swift.AnyClass]
    public static let excludedViewClasses: Swift.Set<Swift.String>
    public static let includedViewClasses: Swift.Set<Swift.String>
    @objc deinit
  }
  @objc public enum SentryReplayQuality : Swift.Int, Swift.CustomStringConvertible {
    case low
    case medium
    case high
    public var description: Swift.String {
      get
    }
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public var sessionSampleRate: Swift.Float
  @objc public var onErrorSampleRate: Swift.Float
  @objc public var maskAllText: Swift.Bool
  @objc public var maskAllImages: Swift.Bool
  @objc public var quality: Sentry.SentryReplayOptions.SentryReplayQuality
  @objc public var maskedViewClasses: [Swift.AnyClass]
  @objc public var unmaskedViewClasses: [Swift.AnyClass]
  @objc public var excludedViewClasses: Swift.Set<Swift.String>
  @objc public var includedViewClasses: Swift.Set<Swift.String>
  @objc public func excludeViewTypeFromSubtreeTraversal(_ viewType: Swift.String)
  @objc public func includeViewTypeInSubtreeTraversal(_ viewType: Swift.String)
  @objc @available(*, deprecated, renamed: "enableViewRendererV2")
  public var enableExperimentalViewRenderer: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public var enableViewRendererV2: Swift.Bool
  @objc public var enableFastViewRendering: Swift.Bool
  @objc convenience override dynamic public init()
  @objc convenience public init(sessionSampleRate: Swift.Float = DefaultValues.sessionSampleRate, onErrorSampleRate: Swift.Float = DefaultValues.onErrorSampleRate, maskAllText: Swift.Bool = DefaultValues.maskAllText, maskAllImages: Swift.Bool = DefaultValues.maskAllImages, enableViewRendererV2: Swift.Bool = DefaultValues.enableViewRendererV2, enableFastViewRendering: Swift.Bool = DefaultValues.enableFastViewRendering)
  @objc deinit
}
final public class PreviewRedactOptions : Sentry.SentryRedactOptions {
  @objc final public let maskAllText: Swift.Bool
  @objc final public let maskAllImages: Swift.Bool
  @objc final public let maskedViewClasses: [Swift.AnyClass]
  @objc final public let unmaskedViewClasses: [Swift.AnyClass]
  @objc final public let excludedViewClasses: Swift.Set<Swift.String>
  @objc final public let includedViewClasses: Swift.Set<Swift.String>
  final public let enableViewRendererV2: Swift.Bool
  public init(maskAllText: Swift.Bool = SentryReplayOptions.DefaultValues.maskAllText, maskAllImages: Swift.Bool = SentryReplayOptions.DefaultValues.maskAllImages, maskedViewClasses: [Swift.AnyClass] = SentryReplayOptions.DefaultValues.maskedViewClasses, unmaskedViewClasses: [Swift.AnyClass] = SentryReplayOptions.DefaultValues.unmaskedViewClasses, excludedViewClasses: Swift.Set<Swift.String> = SentryReplayOptions.DefaultValues.excludedViewClasses, includedViewClasses: Swift.Set<Swift.String> = SentryReplayOptions.DefaultValues.includedViewClasses, enableViewRendererV2: Swift.Bool = SentryReplayOptions.DefaultValues.enableViewRendererV2)
  @objc deinit
}
public enum SentryMetricValue : Swift.Equatable, Swift.Hashable {
  case counter(_: Swift.UInt)
  case gauge(_: Swift.Double)
  case distribution(_: Swift.Double)
  public static func == (a: Sentry.SentryMetricValue, b: Sentry.SentryMetricValue) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Sentry.SentryMetricValue : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension Sentry.SentryLog {
  @objc(SentryLogLevel) public enum Level : Swift.Int {
    case trace
    case debug
    case info
    case warn
    case error
    case fatal
    public init(value: Swift.String) throws
    public var value: Swift.String {
      get
    }
    public func toSeverityNumber() -> Swift.Int
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
@_cdecl("sentry_finishAndSaveTransaction")
public func sentry_finishAndSaveTransaction()
public protocol SentryAttributeValue {
  var asSentryAttributeContent: Sentry.SentryAttributeContent { get }
}
extension Swift.String : Sentry.SentryAttributeValue {
  public var asSentryAttributeContent: Sentry.SentryAttributeContent {
    get
  }
}
extension Swift.Bool : Sentry.SentryAttributeValue {
  public var asSentryAttributeContent: Sentry.SentryAttributeContent {
    get
  }
}
extension Swift.Int : Sentry.SentryAttributeValue {
  public var asSentryAttributeContent: Sentry.SentryAttributeContent {
    get
  }
}
extension Swift.Double : Sentry.SentryAttributeValue {
  public var asSentryAttributeContent: Sentry.SentryAttributeContent {
    get
  }
}
extension Swift.Float : Sentry.SentryAttributeValue {
  public var asSentryAttributeContent: Sentry.SentryAttributeContent {
    get
  }
}
extension Swift.Array : Sentry.SentryAttributeValue {
  public var asSentryAttributeContent: Sentry.SentryAttributeContent {
    get
  }
}
@objc @_inheritsConvenienceInitializers @objcMembers final public class SentryViewScreenshotOptions : ObjectiveC.NSObject, Sentry.SentryRedactOptions {
  @_hasMissingDesignatedInitializers final public class DefaultValues {
    public static let enableViewRendererV2: Swift.Bool
    public static let enableFastViewRendering: Swift.Bool
    public static let maskAllText: Swift.Bool
    public static let maskAllImages: Swift.Bool
    public static let maskedViewClasses: [Swift.AnyClass]
    public static let unmaskedViewClasses: [Swift.AnyClass]
    public static let excludedViewClasses: Swift.Set<Swift.String>
    public static let includedViewClasses: Swift.Set<Swift.String>
    @objc deinit
  }
  @objc final public var enableViewRendererV2: Swift.Bool
  @objc final public var enableFastViewRendering: Swift.Bool
  @objc final public var maskAllImages: Swift.Bool
  @objc final public var maskAllText: Swift.Bool
  @objc final public var maskedViewClasses: [Swift.AnyClass]
  @objc final public var unmaskedViewClasses: [Swift.AnyClass]
  @objc final public var excludedViewClasses: Swift.Set<Swift.String> {
    get
  }
  @objc final public var includedViewClasses: Swift.Set<Swift.String> {
    get
  }
  @objc final public func excludeViewTypeFromSubtreeTraversal(_ viewType: Swift.String)
  @objc final public func includeViewTypeInSubtreeTraversal(_ viewType: Swift.String)
  @objc convenience override dynamic public init()
  @objc public init(enableViewRendererV2: Swift.Bool = DefaultValues.enableViewRendererV2, enableFastViewRendering: Swift.Bool = DefaultValues.enableFastViewRendering, maskAllText: Swift.Bool = DefaultValues.maskAllText, maskAllImages: Swift.Bool = DefaultValues.maskAllImages, maskedViewClasses: [Swift.AnyClass] = DefaultValues.maskedViewClasses, unmaskedViewClasses: [Swift.AnyClass] = DefaultValues.unmaskedViewClasses, excludedViewClasses: Swift.Set<Swift.String> = DefaultValues.excludedViewClasses, includedViewClasses: Swift.Set<Swift.String> = DefaultValues.includedViewClasses)
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
@objc public protocol SentryRedactOptions {
  @objc var maskAllText: Swift.Bool { get }
  @objc var maskAllImages: Swift.Bool { get }
  @objc var maskedViewClasses: [Swift.AnyClass] { get }
  @objc var unmaskedViewClasses: [Swift.AnyClass] { get }
  @objc var excludedViewClasses: Swift.Set<Swift.String> { get }
  @objc var includedViewClasses: Swift.Set<Swift.String> { get }
}
extension Sentry.SentryFeedback.SentryFeedbackSource : Swift.Equatable {}
extension Sentry.SentryFeedback.SentryFeedbackSource : Swift.Hashable {}
extension Sentry.SentryFeedback.SentryFeedbackSource : Swift.RawRepresentable {}
extension Sentry.SentryProfileOptions.SentryProfileLifecycle : Swift.Equatable {}
extension Sentry.SentryProfileOptions.SentryProfileLifecycle : Swift.Hashable {}
extension Sentry.SentryProfileOptions.SentryProfileLifecycle : Swift.RawRepresentable {}
extension Sentry.SentryRedactRegionType : Swift.Hashable {}
extension Sentry.SentryRedactRegionType : Swift.RawRepresentable {}
@available(macOS 10.15, *)
extension Sentry.SentryTracedView : Swift.Sendable {}
extension Sentry.SentryTransactionNameSource : Swift.Equatable {}
extension Sentry.SentryTransactionNameSource : Swift.Hashable {}
extension Sentry.SentryTransactionNameSource : Swift.RawRepresentable {}
extension Sentry.SentryReplayOptions.SentryReplayQuality : Swift.Equatable {}
extension Sentry.SentryReplayOptions.SentryReplayQuality : Swift.Hashable {}
extension Sentry.SentryReplayOptions.SentryReplayQuality : Swift.RawRepresentable {}
extension Sentry.SentryLog.Level : Swift.Equatable {}
extension Sentry.SentryLog.Level : Swift.Hashable {}
extension Sentry.SentryLog.Level : Swift.RawRepresentable {}
